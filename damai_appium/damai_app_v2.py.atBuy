# -*- coding: UTF-8 -*-
"""
__Author__ = "BlueCestbon"
__Version__ = "2.3.0"
__Description__ = "大麦app抢票自动化 - 优化版"
"""

import time
from appium import webdriver
from appium.options.common.base import AppiumOptions
from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

from config import Config


class DamaiBot:
    def __init__(self):
        self.config = Config.load_config()
        self.driver = None
        self.wait = None
        self._setup_driver()

    def _setup_driver(self):
        """初始化驱动配置"""
        capabilities = {
            "platformName": "Android",
            "platformVersion": "15",
            "deviceName": "OnePlus 11",
            "appPackage": "cn.damai",
            "appActivity": ".launcher.splash.SplashMainActivity",
            "unicodeKeyboard": True,
            "resetKeyboard": True,
            "noReset": True,
            "newCommandTimeout": 6000,
            "automationName": "UiAutomator2",
            "skipServerInstallation": False,
            "ignoreHiddenApiPolicyError": True,
            "disableWindowAnimation": True,
            "shouldTerminateApp": False,
            "adbExecTimeout": 20000,
        }

        device_app_info = AppiumOptions()
        device_app_info.load_capabilities(capabilities)
        self.driver = webdriver.Remote(self.config.server_url, options=device_app_info)

        # 优化的设置
        self.driver.update_settings({
            "waitForIdleTimeout": 300,
            "actionAcknowledgmentTimeout": 50,
            "keyInjectionDelay": 0,
            "waitForSelectorTimeout": 500,
            "ignoreUnimportantViews": True,
            "allowInvisibleElements": False,
        })

        self.driver.implicitly_wait(2)
        self.wait = WebDriverWait(self.driver, 3)

    def safe_click(self, element):
        """安全点击元素"""
        try:
            rect = element.rect
            x = rect['x'] + rect['width'] // 2
            y = rect['y'] + rect['height'] // 2
            self.driver.execute_script("mobile: clickGesture", {
                "x": x, "y": y, "duration": 30
            })
        except:
            element.click()

    def quick_screenshot(self, name="debug"):
        """快速截图（仅在失败时使用）"""
        try:
            self.driver.save_screenshot(f"{name}.png")
            print(f"  已保存截图: {name}.png")
        except:
            pass

    def search_and_select_event(self):
        """搜索并选择演出 - 强化版"""
        print("\n步骤1: 搜索演出...")
        
        # 等待首页加载
        time.sleep(2)
        
        # 方案1: 点击搜索ViewGroup（最直接）
        try:
            search_area = self.driver.find_element(
                By.ID, "cn.damai:id/homepage_header_search"
            )
            self.safe_click(search_area)
            print("  ✓ 点击搜索区域")
            time.sleep(0.5)
        except:
            # 方案2: 点击搜索按钮
            try:
                search_btn = self.driver.find_element(
                    By.ID, "cn.damai:id/homepage_header_search_btn"
                )
                self.safe_click(search_btn)
                print("  ✓ 点击搜索按钮")
                time.sleep(0.5)
            except:
                print("  ✗ 无法打开搜索")
                self.quick_screenshot("search_failed")
                return False
        
        # 查找输入框并输入
        input_found = False
        input_box = None
        input_selectors = [
            (By.CLASS_NAME, "android.widget.EditText"),
            (AppiumBy.ANDROID_UIAUTOMATOR, 'new UiSelector().className("android.widget.EditText")'),
        ]
        
        for by, value in input_selectors:
            try:
                input_box = WebDriverWait(self.driver, 2).until(
                    EC.presence_of_element_located((by, value))
                )
                input_box.clear()
                input_box.send_keys(self.config.keyword)
                print(f"  ✓ 输入关键词: {self.config.keyword}")
                input_found = True
                break
            except:
                continue
        
        if not input_found:
            print("  ✗ 未找到输入框")
            self.quick_screenshot("input_not_found")
            return False
        
        # 【关键修复】直接按Enter键触发搜索，避免空格问题
        print("  按Enter触发搜索...")
        try:
            self.driver.press_keycode(66)  # Android keycode 66 = ENTER
            time.sleep(1.5)
            print("  ✓ 已触发搜索")
        except Exception as e:
            print(f"  ⚠ Enter键失败: {e}")
            time.sleep(1.5)
        
        # 【方式1】尝试点击搜索结果列表中的第一项（最常见）
        print("  查找搜索结果...")
        try:
            # 等待搜索结果加载
            time.sleep(1)
            
            # 查找RecyclerView（搜索结果通常在这里）
            result_list = self.driver.find_element(
                By.CLASS_NAME, "androidx.recyclerview.widget.RecyclerView"
            )
            
            # 获取第一个可点击的子元素
            first_result = result_list.find_element(
                AppiumBy.ANDROID_UIAUTOMATOR,
                'new UiSelector().clickable(true).index(0)'
            )
            
            self.safe_click(first_result)
            print("  ✓ 点击第一个搜索结果")
            time.sleep(1.5)
            return True
            
        except Exception as e:
            print(f"  ⚠ 方式1失败: {e}")
        
        # 【方式2】通过坐标点击（假设搜索结果在屏幕上半部分）
        print("  尝试通过坐标点击...")
        try:
            # 获取屏幕尺寸
            size = self.driver.get_window_size()
            width = size['width']
            height = size['height']
            
            # 点击屏幕上部中间位置（通常是第一个搜索结果）
            x = width // 2
            y = height // 4
            
            self.driver.execute_script("mobile: clickGesture", {
                "x": x, "y": y, "duration": 50
            })
            print(f"  ✓ 坐标点击: ({x}, {y})")
            time.sleep(1.5)
            return True
            
        except Exception as e:
            print(f"  ⚠ 方式2失败: {e}")
        
        # 【方式3】查找任意可点击的TextView（宽松匹配）
        print("  尝试查找可点击TextView...")
        try:
            textviews = self.driver.find_elements(
                AppiumBy.ANDROID_UIAUTOMATOR,
                'new UiSelector().className("android.widget.TextView").clickable(true)'
            )
            
            # 点击第一个非空文本的TextView
            for tv in textviews[:5]:  # 只检查前5个
                text = tv.text
                if text and len(text) > 0:
                    self.safe_click(tv)
                    print(f"  ✓ 点击TextView: {text}")
                    time.sleep(1.5)
                    return True
                    
        except Exception as e:
            print(f"  ⚠ 方式3失败: {e}")
        
        print("  ✗ 所有方式均失败")
        self.quick_screenshot("select_event_failed")
        return False

    def select_city_and_date(self):
        """选择城市和日期 - 简化版"""
        print("\n步骤2: 选择城市和日期...")
        
        # 尝试直接点击城市
        try:
            city_el = WebDriverWait(self.driver, 2).until(
                EC.presence_of_element_located((
                    AppiumBy.ANDROID_UIAUTOMATOR,
                    f'new UiSelector().textContains("{self.config.city}")'
                ))
            )
            self.safe_click(city_el)
            print(f"  ✓ 选择城市: {self.config.city}")
            time.sleep(0.5)
        except:
            # 尝试滚动查找
            for _ in range(2):
                try:
                    city_el = self.driver.find_element(
                        AppiumBy.ANDROID_UIAUTOMATOR,
                        f'new UiSelector().textContains("{self.config.city}")'
                    )
                    self.safe_click(city_el)
                    print(f"  ✓ 滚动后选择城市: {self.config.city}")
                    time.sleep(0.5)
                    break
                except:
                    self.driver.execute_script('mobile: scrollGesture', {
                        'left': 100, 'top': 500, 'width': 800, 'height': 1500,
                        'direction': 'down', 'percent': 0.5
                    })
                    time.sleep(0.3)
            else:
                print(f"  ⚠ 未找到城市，继续")
        
        # 日期选择（可选）
        if self.config.date:
            try:
                date_el = self.driver.find_element(
                    AppiumBy.ANDROID_UIAUTOMATOR,
                    f'new UiSelector().textContains("{self.config.date}")'
                )
                self.safe_click(date_el)
                print(f"  ✓ 选择日期: {self.config.date}")
                time.sleep(0.5)
            except:
                print(f"  ⚠ 未找到日期，跳过")
        
        return True

    def click_buy_button(self):
        """点击购买按钮"""
        print("\n步骤3: 点击购买...")
        
        buy_ids = [
            "cn.damai:id/trade_project_detail_purchase_status_bar_container_fl",
            "cn.damai:id/btn_buy",
        ]
        
        # 先尝试ID
        for buy_id in buy_ids:
            try:
                btn = WebDriverWait(self.driver, 2).until(
                    EC.presence_of_element_located((By.ID, buy_id))
                )
                self.safe_click(btn)
                print("  ✓ 购买按钮已点击")
                time.sleep(1)
                return True
            except:
                continue
        
        # 再尝试文本
        try:
            btn = self.driver.find_element(
                AppiumBy.ANDROID_UIAUTOMATOR,
                'new UiSelector().textMatches(".*预约.*|.*购买.*|.*立即.*")'
            )
            self.safe_click(btn)
            print("  ✓ 购买按钮已点击")
            time.sleep(1)
            return True
        except:
            print("  ✗ 未找到购买按钮")
            self.quick_screenshot("buy_button_not_found")
            return False

    def select_price(self):
        """选择票价"""
        print("\n步骤4: 选择票价...")
        
        try:
            price_container = WebDriverWait(self.driver, 3).until(
                EC.presence_of_element_located((
                    By.ID, 'cn.damai:id/project_detail_perform_price_flowlayout'
                ))
            )
            time.sleep(0.3)
            
            target_price = price_container.find_element(
                AppiumBy.ANDROID_UIAUTOMATOR,
                f'new UiSelector().className("android.widget.FrameLayout").index({self.config.price_index})'
            )
            self.safe_click(target_price)
            print(f"  ✓ 票价已选择 (index: {self.config.price_index})")
            time.sleep(0.3)
            return True
        except:
            print(f"  ✗ 票价选择失败")
            self.quick_screenshot("price_selection_failed")
            return False

    def select_quantity(self):
        """选择数量"""
        print("\n步骤5: 选择数量...")
        
        clicks_needed = len(self.config.users) - 1
        if clicks_needed <= 0:
            print(f"  ⚠ 只需1张票，跳过")
            return True
        
        try:
            plus_button = self.driver.find_element(By.ID, 'img_jia')
            for _ in range(clicks_needed):
                self.safe_click(plus_button)
                time.sleep(0.05)
            print(f"  ✓ 数量: {len(self.config.users)}")
            return True
        except:
            print(f"  ⚠ 未找到数量选择器")
            return True  # 不影响流程

    def confirm_purchase(self):
        """确认购买"""
        print("\n步骤6: 确认购买...")
        
        try:
            confirm_btn = WebDriverWait(self.driver, 2).until(
                EC.presence_of_element_located((By.ID, "btn_buy_view"))
            )
            self.safe_click(confirm_btn)
            print("  ✓ 确认按钮已点击")
            time.sleep(0.8)
            return True
        except:
            # 尝试文本查找
            try:
                confirm_btn = self.driver.find_element(
                    AppiumBy.ANDROID_UIAUTOMATOR,
                    'new UiSelector().textMatches(".*确定.*|.*购买.*")'
                )
                self.safe_click(confirm_btn)
                print("  ✓ 确认按钮已点击")
                time.sleep(0.8)
                return True
            except:
                print("  ✗ 未找到确认按钮")
                return False

    def select_users(self):
        """选择购票人"""
        print("\n步骤7: 选择购票人...")
        
        success = False
        for i, user in enumerate(self.config.users):
            try:
                user_el = WebDriverWait(self.driver, 1.5).until(
                    EC.presence_of_element_located((
                        AppiumBy.ANDROID_UIAUTOMATOR,
                        f'new UiSelector().textContains("{user}")'
                    ))
                )
                self.safe_click(user_el)
                print(f"  ✓ 已选择: {user}")
                success = True
                time.sleep(0.1)
            except:
                print(f"  ✗ 未找到用户: {user}")
        
        return success

    def submit_order(self):
        """提交订单"""
        print("\n步骤8: 提交订单...")
        
        if not self.config.if_commit_order:
            print("  ⚠ 配置为不提交，跳过")
            return True
        
        try:
            submit_btn = WebDriverWait(self.driver, 2).until(
                EC.presence_of_element_located((
                    AppiumBy.ANDROID_UIAUTOMATOR,
                    'new UiSelector().text("立即提交")'
                ))
            )
            self.safe_click(submit_btn)
            print("  ✓ 订单已提交")
            return True
        except:
            print("  ✗ 提交失败")
            self.quick_screenshot("submit_failed")
            return False

    def run_ticket_grabbing(self):
        """执行抢票流程"""
        try:
            print("\n" + "="*60)
            print("开始抢票流程")
            print("="*60)
            start_time = time.time()

            steps = [
                ("搜索演出", self.search_and_select_event),
                ("选择城市日期", self.select_city_and_date),
                ("点击购买", self.click_buy_button),
                ("选择票价", self.select_price),
                ("选择数量", self.select_quantity),
                ("确认购买", self.confirm_purchase),
                ("选择用户", self.select_users),
                ("提交订单", self.submit_order),
            ]

            for step_name, step_func in steps:
                if not step_func():
                    print(f"\n✗ 失败于: {step_name}")
                    return False

            elapsed = time.time() - start_time
            print("\n" + "="*60)
            print(f"✓ 流程完成！耗时: {elapsed:.1f}秒")
            print("="*60)
            return True

        except Exception as e:
            print(f"\n✗ 异常: {e}")
            self.quick_screenshot("exception")
            return False

    def run_with_retry(self, max_retries=3):
        """带重试的抢票"""
        for attempt in range(max_retries):
            print(f"\n{'='*60}")
            print(f"第 {attempt + 1}/{max_retries} 次尝试")
            print(f"{'='*60}")
            
            try:
                if self.run_ticket_grabbing():
                    print("\n🎉 抢票成功！")
                    return True
            except Exception as e:
                print(f"\n第 {attempt + 1} 次异常: {e}")
            
            if attempt < max_retries - 1:
                print(f"\n等待2秒后重试...")
                time.sleep(2)
                try:
                    self.driver.quit()
                except:
                    pass
                self._setup_driver()

        print("\n❌ 所有尝试失败")
        try:
            self.driver.quit()
        except:
            pass
        return False


if __name__ == "__main__":
    bot = DamaiBot()
    bot.run_with_retry(max_retries=3)
